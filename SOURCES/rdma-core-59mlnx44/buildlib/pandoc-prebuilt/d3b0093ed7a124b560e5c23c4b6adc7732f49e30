.\" Automatically generated by Pandoc 1.16.0.2
.\"
.TH "mlx5dv_query_port" "3" "" "" ""
.hy
.SH NAME
.PP
mlx5dv_query_port \- Query non standard attributes of IB device port.
.SH SYNOPSIS
.IP
.nf
\f[C]
#include\ <infiniband/mlx5dv.h>

int\ mlx5dv_query_port(struct\ ibv_context\ *context,
\ \ \ \ \ \ \ \ \ \ \ \ \ \ uint32_t\ port_num,
\ \ \ \ \ \ \ \ \ \ \ \ \ \ struct\ mlx5dv_port\ *info);
\f[]
.fi
.SH DESCRIPTION
.PP
Query port info which can be used for some device commands over the DEVX
interface and when directly accessing the hardware resources.
.PP
A function that lets a user query hardware and configuration attributes
associated with the port.
.SH USAGE
.PP
A user should provide the port number to query.
On successful query \f[I]flags\f[] will store a subset of the requested
attributes which are supported/relevant for that port.
.SH ARGUMENTS
.TP
.B \f[I]context\f[]
RDMA device context to work on.
.RS
.RE
.TP
.B \f[I]port_num\f[]
Port number to query.
.RS
.RE
.TP
.B ## \f[I]info\f[]
Stores the returned attributes from the kernel.
.RS
.RE
.IP
.nf
\f[C]
struct\ mlx5dv_port\ {
\ \ \ \ uint64_t\ flags;
\ \ \ \ uint16_t\ vport;
\ \ \ \ uint16_t\ vport_vhca_id;
\ \ \ \ uint16_t\ esw_owner_vhca_id;
\ \ \ \ uint16_t\ rsvd0;
\ \ \ \ uint64_t\ vport_steering_icm_rx;
\ \ \ \ uint64_t\ vport_steering_icm_tx;
\ \ \ \ struct\ mlx5dv_reg\ reg_c0;
};
\f[]
.fi
.TP
.B \f[I]flags\f[]
Bit field of attributes, on successful query \f[I]flags\f[] stores the
valid filled attributes.
.RS
.PP
MLX5DV_QUERY_PORT_VPORT: The vport number of that port.
.PP
MLX5DV_QUERY_PORT_VPORT_VHCA_ID: The VHCA ID of \f[I]vport_num\f[].
.PP
MLX5DV_QUERY_PORT_ESW_OWNER_VHCA_ID: The E\-Switch owner of
\f[I]vport_num\f[].
.PP
MLX5DV_QUERY_PORT_VPORT_STEERING_ICM_RX: The ICM RX address when
directing traffic.
.PP
MLX5DV_QUERY_PORT_VPORT_STEERING_ICM_TX: The ICM TX address when
directing traffic.
.PP
MLX5DV_QUERY_PORT_VPORT_REG_C0: Register C0 value used to identify
egress of \f[I]vport_num\f[].
.RE
.TP
.B \f[I]vport\f[]
The VPORT number of that port.
.RS
.RE
.TP
.B \f[I]vport_vhca_id\f[]
The VHCA ID of \f[I]vport_num\f[].
.RS
.RE
.TP
.B \f[I]rsvd0\f[]
A reserved field.
Not to be used.
.RS
.RE
.TP
.B \f[I]esw_owner_vhca_id\f[]
The E\-Switch owner of \f[I]vport_num\f[].
.RS
.RE
.TP
.B \f[I]vport_steering_ica_rx\f[]
The ICM RX address when directing traffic.
.RS
.RE
.TP
.B \f[I]vport_steering_icm_tx\f[]
The ICM TX address when directing traffic.
.RS
.RE
.TP
.B ## reg_c0
Register C0 value used to identify traffic of \f[I]vport_num\f[].
.RS
.RE
.IP
.nf
\f[C]
struct\ mlx5dv_reg\ {
\ \ \ \ \ \ \ \ uint32_t\ value;
\ \ \ \ \ \ \ \ uint32_t\ mask;
};
\f[]
.fi
.TP
.B \f[I]value\f[]
The value that should be used as match.
.RS
.RE
.TP
.B \f[I]mask\f[]
The mask that should be used when matching.
.RS
.RE
.SH RETURN VALUE
.PP
returns 0 on success, or the value of errno on failure (which indicates
the failure reason).
.SH EXAMPLE
.IP
.nf
\f[C]
for\ (i\ =\ 1;\ i\ <=\ ports;\ i++)\ {
\ \ \ \ ret\ =\ mlx5dv_query_port(context,\ i,\ &port_info);
\ \ \ \ if\ (ret)\ {
\ \ \ \ \ \ \ \ printf("Error\ querying\ port\ %d\\n",\ i);
\ \ \ \ \ \ \ \ break;
\ \ \ \ }

\ \ \ \ printf("Port:\ %d:\\n",\ i);

\ \ \ \ if\ (port_info.flags\ &\ MLX5DV_QUERY_PORT_VPORT)
\ \ \ \ \ \ \ \ printf("\\tvport_num:\ 0x%x\\n",\ port_info.vport_num);

\ \ \ \ if\ (port_info.flags\ &\ MLX5DV_QUERY_PORT_VPORT_REG_C0)
\ \ \ \ \ \ \ \ printf("\\treg_c0:\ val:\ 0x%x\ mask:\ 0x%x\\n",
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ port_info.reg_c0.value,
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ port_info.reg_c0.mask);
}
\f[]
.fi
.PP
Mark Bloch <mbloch@nvidia.com>
